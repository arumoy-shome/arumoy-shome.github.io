{
  "hash": "396aca1a5c2deebbc8bd1f3175754fa5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Extracting the Module and Function Names from Python ASTs\ndate: 2024-03-23\nabstract: How to extract the module and function name from Python Abstract Syntax Trees.\ncategories: [\"python\"]\n---\n\n\n\n\n# Preliminaries: Python `ast` module\n\nPython has a built-in `ast` module which provides detailed documentation on the various nodes used to represent different elements of Python source code.\n\nWe can use the `ast.parse` method to create a AST from a given Python source code. Here is an example of how a function call is represented in a AST.\n\n::: {#fa4c06d1 .cell execution_count=1}\n``` {.python .cell-code}\nimport ast\nast.parse(\"foo(x, y)\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n<ast.Module at 0x1063c3950>\n```\n:::\n:::\n\n\nThe `ast.parse` method returns a `ast.Module` object which by itself is not very helpful. To view the internal structure of the tree, we can use the `ast.dump` method.\n\n::: {#5f17333f .cell execution_count=2}\n``` {.python .cell-code}\nast.dump(ast.parse(\"foo(x, y)\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n\"Module(body=[Expr(value=Call(func=Name(id='foo', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='y', ctx=Load())]))])\"\n```\n:::\n:::\n\n\nWe can pass the `indent` argument to `ast.dump` along with a `print` statement to make the output more readable.\n\n::: {#a553dec9 .cell execution_count=3}\n``` {#lst-base-case .python .cell-code lst-cap=\"Base case\"}\nprint(ast.dump(ast.parse(\"foo(x, y)\"), indent=4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModule(\n    body=[\n        Expr(\n            value=Call(\n                func=Name(id='foo', ctx=Load()),\n                args=[\n                    Name(id='x', ctx=Load()),\n                    Name(id='y', ctx=Load())]))])\n```\n:::\n:::\n\n\nNote that the function call is represented by a `ast.Call` node which contains a `func` and `args` attribute. The function name (in our case, `foo`) is represented by a `ast.Name` node, with the actual name under the `id` attribute.\n\nAnd here is the AST when we want to use a function defined in a different module.\n\n::: {#e2e40618 .cell execution_count=4}\n``` {#lst-single-nest .python .cell-code lst-cap=\"Single nested function call\"}\nprint(ast.dump(ast.parse(\"bar.foo(x, y)\"), indent=4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModule(\n    body=[\n        Expr(\n            value=Call(\n                func=Attribute(\n                    value=Name(id='bar', ctx=Load()),\n                    attr='foo',\n                    ctx=Load()),\n                args=[\n                    Name(id='x', ctx=Load()),\n                    Name(id='y', ctx=Load())]))])\n```\n:::\n:::\n\n\nThings are a bit different now. We see that the `Call.func` is no longer a `ast.Name` node, but instead an `ast.Attribute` node. `Attribute.value` is now a `ast.Name` node with the name of the module (in our case `bar`) on the `id` attribute and the name of the function on the `attr` attribute.\n\nLets examine something a bit more complicated: What if the function is in a submodule?\n\n::: {#3c5ce0da .cell execution_count=5}\n``` {.python .cell-code}\nprint(ast.dump(ast.parse(\"baz.bar.foo(x, y)\"), indent=4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModule(\n    body=[\n        Expr(\n            value=Call(\n                func=Attribute(\n                    value=Attribute(\n                        value=Name(id='baz', ctx=Load()),\n                        attr='bar',\n                        ctx=Load()),\n                    attr='foo',\n                    ctx=Load()),\n                args=[\n                    Name(id='x', ctx=Load()),\n                    Name(id='y', ctx=Load())]))])\n```\n:::\n:::\n\n\nAnd even more nested?\n\n::: {#a666b26f .cell execution_count=6}\n``` {.python .cell-code}\nprint(ast.dump(ast.parse(\"quack.baz.bar.foo(x, y)\"), indent=4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModule(\n    body=[\n        Expr(\n            value=Call(\n                func=Attribute(\n                    value=Attribute(\n                        value=Attribute(\n                            value=Name(id='quack', ctx=Load()),\n                            attr='baz',\n                            ctx=Load()),\n                        attr='bar',\n                        ctx=Load()),\n                    attr='foo',\n                    ctx=Load()),\n                args=[\n                    Name(id='x', ctx=Load()),\n                    Name(id='y', ctx=Load())]))])\n```\n:::\n:::\n\n\nIt seems that nested function calls are represented using nested `ast.Attribute` nodes. The top level module name is always a `ast.Name` node under the deepest `ast.Attribute.value` node. And the function name is always under the first `ast.Attribute.attr` node\n\n# Extracting the Function Names\n\nLets start with the simplest case, where we are only interested in the function names (ie. we only want to extract `foo` from all scenarios presented above). There are two cases to consider here:\n\n1. If its a direct function call, then the `Call.func` node will contain a `Name` node.\n2. If its a nested function call, then `Call.func` will contain nested `Attribute` nodes. The name of the function will be under the first `Attribute.attr`.\n\nWe can do this using the `ast.NodeVisitor` class. Lets create a `FunctionNameCollector` class which inherits from `ast.NodeVisitor`. In the class, we define a `visit_Name` and `visit_Attribute` methods which are called every time we visit a `Name` or `Attribute` method respectively (more on this later).\n\n::: {#69b93336 .cell execution_count=7}\n``` {.python .cell-code}\nclass FunctionNameCollector(ast.NodeVisitor):\n    def __init__(self):\n        self.names = []\n\n    def visit_Name(self, node: ast.Name) -> None:\n        self.names.append(node.id)\n\n    def visit_Attribute(self, node: ast.Attribute) -> None:\n        self.names.append(node.attr)\n\n\ntests = [\"foo(x, y)\", \"bar.foo(x, y)\", \"baz.bar.foo(x, y)\", \"quack.baz.bar.foo(x, y)\"]\n\ntrees = [ast.parse(test) for test in tests]\ncall_nodes = [\n    node for tree in trees for node in ast.walk(tree) if isinstance(node, ast.Call)\n]\ncollector = FunctionNameCollector()\nfor node in call_nodes:\n    collector.visit(node.func)\n\ncollector.names\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n['foo', 'foo', 'foo', 'foo']\n```\n:::\n:::\n\n\nI collect all the `ast.Call` nodes in our test cases using the `ast.walk` function which returns a generator that yields every child node under the given AST. Then I call the `visit` method provided by `ast.NodeVisitor` which visits only the direct child nodes of all `Call.func` nodes in our test cases.\n\n# Collecting Both Module and Function Names\n\nHere is where things get a bit more interesting. Here are the cases to consider:\n\n1. The base case is that we have a direct function call, in which case we need to extract the function name from `Name.id` under `Call.func` (same as before).\n2. However, if it is a nested function call, then:\n    a. The function name will be under the first `Attribute.attr` and\n    b. The module name will be under the last `Attribute.value.id`.\n\nSo the `visit_Name` method remains the same however, we do need to modify the `visit_Attribute` method such that it traverses all child nodes under `Attribute.value` until we hit the base case. Here is the modified code.\n\n::: {#04290394 .cell execution_count=8}\n``` {.python .cell-code}\nclass NameCollector(ast.NodeVisitor):\n    def __init__(self):\n        self.names = []\n        self.stack = []\n\n    def visit_Name(self, node: ast.Name) -> None:\n        if self.stack:\n            self.names.append((node.id, self.stack[0].attr))\n        else:\n            self.names.append((None, node.id))\n\n    def visit_Attribute(self, node: ast.Attribute) -> None:\n        self.stack.append(node)\n        self.visit(node.value)\n\ncollector = NameCollector()\nfor node in call_nodes:\n    collector.visit(node.func)\n\ncollector.names\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n[(None, 'foo'), ('bar', 'foo'), ('baz', 'foo'), ('quack', 'foo')]\n```\n:::\n:::\n\n\nThe code is similar to `FunctionNameCollector` defined above, with a few key changes. The `collector.names` now returns a list of tuples containing the `module, function` names.\n\nI use a stack to keep track of the `Attribute` nodes we visit. Whenever we visit an `Attribute` node, I append it to the stack and then call the `NodeVisitor.visit` method on the Node under its `value` attribute.\n\nWhen we visit a `Name` node, it can either be because we are at the base case (a direct function call) or because we have reached the last `Attribute.value` node. If the stack is not empty, then its the latter which means the `Name` node is the module name and the function name is under the first `Attribute.attr` in the stack. Otherwise, its a direct function call so the `Name` node is the function name. Since we don't have a module in this case, we return `None` in the tuple.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}